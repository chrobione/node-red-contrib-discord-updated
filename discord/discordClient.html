<script type="text/javascript">
    RED.nodes.registerType('discordClient',{
        category: 'discord · advanced tools',
        color: '#7289da',
        defaults: {
            name: {value: "", required: false},
            token: {value: "", required: true, type: "discord-token"}
        },
        inputs: 1,
        outputs: 1,
        icon: "font-awesome/fa-code",
        label: function() {
            return this.name||"discordClient";
        }
    });
</script>
<script type="text/x-red" data-template-name="discordClient">
    <div class="form-row">
        <label for="node-input-token"><i class="icon-tag"></i> token</label>
        <input type="text" id="node-input-token" placeholder="token">
    </div>
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
</script>
<script type="text/x-red" data-help-name="discordClient">
    <div class="alert alert-danger"><strong>ADVANCED ONLY.</strong> This exposes the raw Discord.js client. Mistakes can crash Node-RED or leak memory.</div>
    <p><strong>What it does</strong> — Attaches <code>msg.discord</code> to the message, giving you full access to the underlying Discord.js client.</p>
    <p><strong>When to use it</strong> — Only if the other nodes cannot do what you need (for example, experimental APIs). You must write JavaScript in a Function node afterwards to call the client safely.</p>
    <h3>Tips</h3>
    <ul>
      <li>Never fork the message (send it to multiple outputs) while the client reference is attached. Instead, use a single Function node and call <code>delete msg.discord</code> before wiring to other nodes.</li>
      <li>Wrap your client calls in try/catch blocks and call <code>done(err)</code> to avoid hanging flows.</li>
    </ul>
</script>
